# 多线程

## 程序、进程、线程

### 进程与线程

![image-20210201225324150](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210201225324150.png)

- 程序(program)是为完成特定任务、用某种语言编写的一-组指令的集合。即指一段静态的代码，静态对象。

- 进程(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程:有它自身的产生、存在和消亡的过程。一生命周期
  - 如:运行中的QQ，运行中的MP3播放器
  - 程序是靜态的，进程是动态的
  - 进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域
- 线程(thread)，进程可进一- 步细化为线程，是一个程序内部的一条执行路径。
    - 若一个进程同一时间并行执行多个线程，就是支持多线程的
    - 线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc),线程切换的开销小
    - 一个进程中的多个线程共享相同的内存单元/内存地址空间>它们从同一堆中分配对象，可以问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。
    - 线程各自独立有栈和PC，共享堆和方法区

![image-20210201225447008](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210201225447008.png)



### 单核CPU和多核CPU的理解

- 单核CPU,其实是一种假的多线程，因为在一 一个时间单元内，也只能执行一一个线程的任务。例如:虽然有多车道，但是收费站只有-一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果有某个人不想交钱，那么收费人员可以把他“挂起”(晾着他， 等他想通了，准备好了钱，再去收费)。但是因为CPU时间单元特别短，因此感觉不出来。

- 如果是多核的话，才能更好的发挥多线程的效率。 (现在的服务器都是多核的)

- 一个Java应用程序java.exe，其实至少有三个线程: main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。

### 并行与并发
- 并行:多个CPU同时执行多个任务。比如:多个人同时做不同的事。
- 并发: 一个CPU(采用时间片)同时执行多个任务。比如:秒杀、多个人做同一件事.


### 使用多线程的优点

背景:以单核CPU为例， 只使用单个线程先后完成多个任务(调用多个方法)，肯定比用多个线程来完成用的时间更短，为何仍需多线程呢?
**多线程程序的优点:**

1. 提高应用程序的响应。对图形化界面更有意义，可增强用户体验。
2. 提高计算机系统CPU的利用率
3. 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改

### 何时需要多线程

- 程序需要同时执行两个或多个任务。
- 程序需要实现- -些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。
- 需要一些后台运行的程序时。

## 线程的创建和使用

**引例一**

如下的程序不是多线程!

```java
public class Sample {
public void method1(String str) {
	System.out.println(str);
}
public void method2(String str) {
	method1(str);
}
public static void main(String[] args) {
	Sample s = new Sample(); 
	s.method2( "hello!");
}

```

其中的路径为`main->method2->method1`仅仅只有一条路径

### 线程的创建和启动

- Java语言的JVM允许程序运行多个线程，它通过java.lang.Thrend类来体现。
- Thread类的特性
  - 每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体
  - 通过该Thread对象的star()方法来启动这个线程，而非直接调用run()

### 方式一:继承于thread类创建线程

**步骤**

1. 创建-个继承于Thread类的子类
2. 重写Thread类的run()
3. 创建Thread 类的子类的对象
4. 通过此对象调用start()

**例子：遍历1~100内的偶数**

```java
package com.dreamcold.thread;

public class Demo01 {
    public static void main(String[] args){
        MyThread thread = new MyThread();
        thread.start();
    }
}

class MyThread extends Thread{
    @Override
    public void run() {
        for(int i=0;i<100;i++){
            if(i%2==0){
                System.out.println(i);
            }
        }
    }
}
```

效果：

<img src="https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210202122950949.png" alt="image-20210202122950949" style="zoom:80%;" />

主线程和创建的新的线程会交替执行：

```java
package com.dreamcold.thread;

public class Demo01 {
    public static void main(String[] args){
        MyThread thread = new MyThread();
        thread.start();
        for (int i = 0; i < 100000; i++) {
            if (i%2==0){
                System.out.println(i+"****************");
            }
        }
    }
}

class MyThread extends Thread{
    @Override
    public void run() {
        for(int i=0;i<100000;i++){
            if(i%2==0){
                System.out.println(i);
            }
        }
    }
}
```

效果：

<img src="https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210202123315162.png" alt="image-20210202123315162" style="zoom:80%;" />

**问题一：能否不调用start方法而调用run方法来创建一个线程？**

不可以，因为调用run方法相当于调用了一个普通的方法，不会创建新的线程

**问题二：能否重复调用线程的start方法来创建一个新的线程？**

不可以，线程中的start方法仅仅可以调用一次，否则会抛出IllegalThreadstateException，此时应该新建一个线程对象再调用start方法。

```java
MyThread thread2 = new MyThread();
thread2.start();
```

**练习:创建两个分线程，其中一个线程追历100以内的偶数，另一个线程遍历100以内的奇数**

```java
package com.dreamcold.thread;

public class Demo02 {
    public static void main(String[] args) {
        MyThreadOdd thread1=new MyThreadOdd();
        MyThreadEven thread2=new MyThreadEven();
        thread1.start();
        thread2.start();
    }
}

//打印奇数
class  MyThreadOdd extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i%2!=0){
                System.out.println(Thread.currentThread().getName()+":"+i);
            }
        }
    }
}

//打印偶数
class MyThreadEven extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 100 ;i++){
            if (i%2==0){
                System.out.println(Thread.currentThread().getName()+":"+i);
            }
        }
    }
}

```

效果：

![image-20210202125339137](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210202125339137.png)

**匿名创建线程的方式**

```java
package com.dreamcold.thread;

public class Demo03 {
    public static void main(String[] args) {
        new Thread(){
            @Override
            public void run() {
                for (int i = 0; i < 100; i++) {
                    System.out.println(i);
                }
            }
        }.start();
    }
}
```

在仅仅使用一次该线程的时候选择该方法进行创建：

效果：

![image-20210202125639577](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210202125639577.png)

### Thread类有关方法

- void start(): 启动线程，并执行对象的run()方法
- run(): 线程在被调度时执行的操作
- String getName(): 返回线程的名称
- void setName(String name):设置该线程名称
- static Thread currentThread():返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类
- yield():释放当前cpu的执行权
- join():在线程a中调用线程的join(),此时线程a就进入阻塞状态，直到线和完全执行完以后，线程a才
  结束阻塞状态
- stop():强制线程生命期结束，不推荐使用,已经过时
- sleep(long millitime): i当前线程“睡眠”指定的millitime毫秒。在指定的millitime 毫秒时间内，当前线程是阻塞状态。
- isAlive():判断当前线程是否存活

**示例一：给线程起名字**

```java
package com.dreamcold.thread;

public class Demo04 {
    public static void main(String[] args) {
        HelloThread h1=new HelloThread();
        h1.setName("thread 1");
        h1.start();
        //给主线程命名
        Thread.currentThread().setName("main thread");

        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName()+":"+i);
        }
    }
}

class HelloThread extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName()+":"+i);
        }
    }
}
```

效果：

![image-20210202153941001](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210202153941001.png)



**示例二：通过写子类构造器给线程起名字**

```java
class HelloThread extends Thread{
    
    HelloThread(String str){
        super(str);
    }
    
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName()+":"+i);
        }
    }
}

public class Demo04 {
    public static void main(String[] args) {
        HelloThread h1=new HelloThread("thread1");//调用构造器的时候给其起名
    }
}
```

**示例三:yield方法的使用**

```java
package com.dreamcold.thread;

public class Demo04 {
    public static void main(String[] args) {
        HelloThread h1=new HelloThread("thread1");
        h1.start();
        //给主线程命名
        Thread.currentThread().setName("main thread");

        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName()+":"+i);
        }
    }
}

class HelloThread extends Thread{

    HelloThread(String str){
        super(str);
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName()+":"+i);
            if (i%20==0){
                this.yield();//   Thread.currentThread().yield();

            }
        }
    }
}
```

**示例五：join方法**

```java
package com.dreamcold.thread;

public class Demo04 {
    public static void main(String[] args) {
        HelloThread h1=new HelloThread("thread1");
        h1.start();
        //给主线程命名
        Thread.currentThread().setName("main thread");
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName()+":"+i);
            if (i==20) {
                try {
                    h1.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class HelloThread extends Thread{

    HelloThread(String str){
        super(str);
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName()+":"+i);
            if (i%20==0){
                this.yield();//   Thread.currentThread().yield();

            }
        }
    }
}
```

效果：

![image-20210202155625621](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210202155625621.png)

**示例六：sleep方法演示**

```java
class HelloThread extends Thread{

    HelloThread(String str){
        super(str);
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName()+":"+i);
            if (i%2==0){
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```



### 线程的调度

#### 调度策略

![image-20210203133242272](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210203133242272.png)

#### Java的调度方法

- 同优先级线程组成先进先出队列(先到先服务)，使用时间片策略
- 对高优先级，使用优先调度的抢占式策略

#### 设置优先级

**在Thread类中有三个常量来进行表示优先级，从1~10**

```java
MAX_PRIORITY=10
MIN_PRIORITY=1
NORM_PRIORITY=5
```

**如何获取和设置当前线程的优先级？**

```java
getPriority();//获取优先级
setPriority(int p);//设置优先级
```

示例：给主线程更高的优先级，执行的过程中打印优先级

```java
package com.dreamcold.thread;

public class Demo04 {
    public static void main(String[] args) {
        HelloThread h1=new HelloThread("thread1");
        h1.start();
        //给主线程命名
        Thread.currentThread().setName("main thread");
        //给主线程设置比较高的优先级
        Thread.currentThread().setPriority(Thread.MAX_PRIORITY);

        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName()+":"+Thread.currentThread().getPriority()+":"+i);

        }
    }
}

class HelloThread extends Thread{

    HelloThread(String str){
        super(str);
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName()+":"+Thread.currentThread().getPriority()+":"+i);
            if (i%2==0){
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

**说明:高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味者只有当高优先级的线程执行完以后，低优先级的线程才执行。**

效果：

![image-20210203134241491](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210203134241491.png)



### 多窗口买票的例子

例子:创建三个窗口卖票，总票数为100张

```java
package com.dreamcold.thread;

public class Window  extends Thread{

    public static void main(String[] args) {
        Window t1=new Window();
        Window t2=new Window();
        Window t3=new Window();
        t1.setName("窗口一");
        t2.setName("窗口二");
        t3.setName("窗口三");
        t1.start();
        t2.start();
        t3.start();

    }

    private int ticket=100;

    @Override
    public void run() {
        while(true){
            if(ticket>0){
                System.out.println(getName()+",买票,票号为: "+ticket);
                ticket--;
            }else{
                break;
            }
        }
    }
}
```

效果：

![image-20210203135015442](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210203135015442.png)

![image-20210203135028039](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210203135028039.png)

窗口二和窗口三都在卖第100张票，每个窗口有100张票，我们将ticket改为static变量，却发现如上的问题还是出现了

```java
package com.dreamcold.thread;

public class Window  extends Thread{

    public static void main(String[] args) {
        Window t1=new Window();
        Window t2=new Window();
        Window t3=new Window();
        t1.setName("窗口一");
        t2.setName("窗口二");
        t3.setName("窗口三");
        t1.start();
        t2.start();
        t3.start();

    }

    private static int ticket=100;

    @Override
    public void run() {
        while(true){
            if(ticket>0){
                System.out.println(getName()+",买票,票号为: "+ticket);
                ticket--;
            }else{
                break;
            }
        }
    }
}
```

出现效果：出现了线程安全的问题

![image-20210203135354179](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210203135354179.png)



### 方式二：实现Runnable接口的方式来创建线程

创建多线程的方式二:实现Runnable接口
1.创建一个实现TRunnable接口的类
2.实现类去实现Runnable中的抽象方法: run()
3.创建实现类的对象
4.将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
5.通过Thread类的对象 调用start()

示例一：通过实现Runnable接口来创建线程

```java
package com.dreamcold.thread;

public class Demo05 {
    public static void main(String[] args){
        //1.可以直接创建实现类的对象
        ThreadRunable mthread=new ThreadRunable();
        //2.将此对象作为参数传递到对应的Thread构造器中
        Thread thread=new Thread(mthread);
        //3. 启动线程
        thread.start();

    }
}

class ThreadRunable implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if(i%2==0){
                System.out.println(i);
            }
        }
    }
}
```

效果：

![image-20210203140050567](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210203140050567.png)

示例二：通过实现Runnable接口来实现三个窗口买票

```java
package com.dreamcold.thread;

public class Window1 implements Runnable{

    public static void main(String[] args) {
        //因为是一个Window对象所以里面的ticket只有一份
        Window1 w=new Window1();
        Thread t1=new Thread(w);
        Thread t2=new Thread(w);
        Thread t3=new Thread(w);
        t1.setName("t1");
        t2.setName("t2");
        t3.setName("t3");
        t1.start();
        t2.start();
        t3.start();

    }

    //这里不需要static修饰
    private int ticket=100;

    @Override
    public void run() {
        while(true){
            if(ticket>0){
                System.out.println(Thread.currentThread().getName()+",买票,票号为: "+ticket);
                ticket--;
            }else{
                break;
            }
        }
    }
}
```

效果：

![image-20210203140757320](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210203140757320.png)

### 两种创建线程的方式的对比

比较创建线程的两种方式。
**开发中:优先选择:实现Runnable 接口的方式**
原因: 

1. 实现的方式没有类的单继承性的局限性
2. 实现的方式更适合来处理多个线程有共享数据的情况。
3. 联系: public class Thread implements Runnable
4. 相同点:两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。|

## 生命周期

- JDK中用Thread.State类定义了线程的几种状态要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五.种状态:
- 新建:当一个Thread类或其 子类的对象被声明并创建时，新生的线程对象处于新建状态
- 就绪:处于新建状态的线程被star()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源
- 运行:当就绪的线程被调度并获得CPU资源时,便进入运行状态，run()方法定 义了线程的操作和功能
- 阻塞:在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时中止自己的执行，进入阻塞状态
- 死亡:线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束

**线程的声明周期图如下：**

![image-20210203141514817](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210203141514817.png)



## 线程的同步

对于以上的三个窗口买票的问题中，我们发现出现了线程不安全的问题

理想状态：

![image-20210203142129461](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210203142129461.png)

极端状态：

<img src="https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210203142233347.png" alt="image-20210203142233347" style="zoom:80%;" />

- 问题:卖票过程中，出现了重票、错票-->出现了线程的安全问题
- 问题出现的原因:当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票
- 问题的提出
  - 多个线程执行的不确定性引起执行结果的不稳定
  - 多个线程对账本的共享，会造成操作的不完整性，会破坏数据。

![image-20210203142455854](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210203142455854.png)

- 当一个线租在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket的时候，其他的线程才可以参与进来，这种情况即使我们的线程a出现了阻塞也不可以被改变



### 同步代码块

```java
synchronized(同步监视器){
// 需要被同步的代码
}
```

- 说明:操作共享数据的代码，即为需要被同步的代码

- 共享教据:多个线程共同操作的变量

- 比如: ticket]就是共享数据。
- 同步监视器简称锁，任何一个类的对象，都可以充当锁。
- **要求:多个线程必须要共用同一把锁。**
- 多个共享数据是出现线程安全问题的原因

修改后的代码：

```java
package com.dreamcold.thread;

public class Window1 implements Runnable{

    public static void main(String[] args) {
        //因为是一个Window对象所以里面的ticket只有一份
        Window1 w=new Window1();
        Thread t1=new Thread(w);
        Thread t2=new Thread(w);
        Thread t3=new Thread(w);
        t1.setName("t1");
        t2.setName("t2");
        t3.setName("t3");
        t1.start();
        t2.start();
        t3.start();

    }

    //这里不需要static修饰
    private int ticket=100;
    Object object=new Object();

    @Override
    public void run() {
       synchronized (object){
           while(true){
               if(ticket>0){
                   System.out.println(Thread.currentThread().getName()+",买票,票号为: "+ticket);
                   ticket--;
               }else{
                   break;
               }
           }
       }
    }
}
```

效果：

![image-20210204194431037](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210204194431037.png)

要求:多个线程必须要共用同一把锁。举例：即多个线程要锁住一个Object对象

```java
package com.dreamcold.thread;

public class Window1 implements Runnable{

    public static void main(String[] args) {
        //因为是一个Window对象所以里面的ticket只有一份
        Window1 w=new Window1();
        Thread t1=new Thread(w);
        Thread t2=new Thread(w);
        Thread t3=new Thread(w);
        t1.setName("t1");
        t2.setName("t2");
        t3.setName("t3");
        t1.start();
        t2.start();
        t3.start();

    }

    //这里不需要static修饰
    private int ticket=100;
//    Object object=new Object();

    @Override
    public void run() { 
        //每个线程都有一个Object对象，不是听一个锁
        Object object=new Object();
       synchronized (object){
           while(true){
               if(ticket>0){
                   System.out.println(Thread.currentThread().getName()+",买票,票号为: "+ticket);
                   ticket--;
               }else{
                   break;
               }
           }
       }
    }
}
```

- 同步的方式，解决了线程的安全问题。--- 好处
- 操作同步代码时，只能有一个线程参与， 其他线程等待。相当于一个单线程的过程，效率会比较低---局限性

### 同步代码块的原理

<img src="https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210204195631268.png" alt="image-20210204195631268" style="zoom:80%;" />

- synchronized相当于一个门，一开始门是绿色的，锁是开的，t1,t2,t3三个线程可以抢占锁

<img src="https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210204200022959.png" alt="image-20210204200022959" style="zoom:80%;" />

- 假如t1抢到了锁，t1进去了，会把门关上，图中锁的位置变成红色，这时其他线程就进不去了

- t1在里面执行自己的代码，这时候t1无论经历了什么比如阻塞、挂起

  <img src="https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210204200202326.png" alt="image-20210204200202326" style="zoom:80%;" />

- t1执行完后退出，释放锁，将门打开，可以和其他线程竞争来得到锁进而执行

  <img src="https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210204200344296.png" alt="image-20210204200344296" style="zoom:80%;" />
  
  

### 同步代码块解决继承Thread类的线程安全问题

```java
package com.dreamcold.thread;

public class Window  extends Thread{

    public static void main(String[] args) {
        Window t1=new Window();
        Window t2=new Window();
        Window t3=new Window();
        t1.setName("窗口一");
        t2.setName("窗口二");
        t3.setName("窗口三");
        t1.start();
        t2.start();
        t3.start();

    }

    private static int ticket=100;
    private static Object object;//确保锁住的对象是唯一的，即多个线程锁住一个对象

    @Override
    public void run() {
       synchronized (object){
           while(true){
               if(ticket>0){
                   System.out.println(getName()+",买票,票号为: "+ticket);
                   ticket--;
               }else{
                   break;
               }
           }
       }
    }
}
```

注意为了简写，我们可以锁住自身作为Object对象：

```java
package com.dreamcold.thread;

public class Window  extends Thread{

    public static void main(String[] args) {
        Window t1=new Window();
        Window t2=new Window();
        Window t3=new Window();
        t1.setName("窗口一");
        t2.setName("窗口二");
        t3.setName("窗口三");
        t1.start();
        t2.start();
        t3.start();

    }

    private static int ticket=100;
    private static Object object=new Object();

    @Override
    public void run() {
       synchronized (this){//this指向的是Window对象
           while(true){
               if(ticket>0){
                   System.out.println(getName()+",买票,票号为: "+ticket);
                   ticket--;
               }else{
                   break;
               }
           }
       }
    }
}

```

除了可以锁住自身，还可以锁住`class`

```java
package com.dreamcold.thread;

public class Window  extends Thread{

    public static void main(String[] args) {
        Window t1=new Window();
        Window t2=new Window();
        Window t3=new Window();
        t1.setName("窗口一");
        t2.setName("窗口二");
        t3.setName("窗口三");
        t1.start();
        t2.start();
        t3.start();

    }

    private static int ticket=100;
    private static Object object=new Object();

    @Override
    public void run() {
       synchronized (Window.class){
           while(true){
               if(ticket>0){
                   System.out.println(getName()+",买票,票号为: "+ticket);
                   ticket--;
               }else{
                   break;
               }
           }
       }
    }
}

```

- 补充:在实现Runnable接口创建多线程的方式中，我们可以考想使用this充当同步监视器。
- 说明:在继承Thread 类创建多线程的方式中，慎用this 充当同步监视器。考虑使用当前类来当同步监视器

### 同步方法

- 如果操作共享数据的代码完整的声明在一个方法中， 我们不妨将此方法声明同步的。
- 不适合将run方法改成我们的同步方法

例一：同步代码块写法

```java
package com.dreamcold.thread;

public class Window  implements Runnable{

    public static void main(String[] args) {
        //因为是一个Window对象所以里面的ticket只有一份
        Window w=new Window();
        Thread t1=new Thread(w);
        Thread t2=new Thread(w);
        Thread t3=new Thread(w);
        t1.setName("t1");
        t2.setName("t2");
        t3.setName("t3");
        t1.start();
        t2.start();
        t3.start();


    }

    private static int ticket=100;
    private static Object object=new Object();

    @Override
    public void run() {

           while(true){
                sale();
           }

    }

    private void sale() {
      synchronized (Window.class){
          if(ticket>0){
              try {
                  Thread.sleep(100);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              System.out.println(getName()+",买票,票号为: "+ticket);
              ticket--;
          }
      }
    }
}

```

将方法声明为`synchronized`,使用同步方法解决实现Runnable接口的线程安全问题

```java
package com.dreamcold.thread;

public class Window  implements Runnable{

    public static void main(String[] args) {
        //因为是一个Window对象所以里面的ticket只有一份
        Window w=new Window();
        Thread t1=new Thread(w);
        Thread t2=new Thread(w);
        Thread t3=new Thread(w);
        t1.setName("t1");
        t2.setName("t2");
        t3.setName("t3");
        t1.start();
        t2.start();
        t3.start();
    }

    private static int ticket=100;
    private static Object object=new Object();

    @Override
    public void run() {

           while(true){
                sale();
           }

    }

    private synchronized void sale()  {
      
          if(ticket>0){
              try {
                  Thread.sleep(100);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              System.out.println(getName()+",买票,票号为: "+ticket);
              ticket--;
          }
      
    }
}

```

将方法声明为`synchronized`,使用同步方法解决继承Thread类的线程安全问题,注意的是同步方法要声明为static的，因为声明为static说明其锁住的是class

```java
package com.dreamcold.thread;

public class Window  extends Thread{

    public static void main(String[] args) {
        Window t1=new Window();
        Window t2=new Window();
        Window t3=new Window();
        t1.setName("窗口一");
        t2.setName("窗口二");
        t3.setName("窗口三");
        t1.start();
        t2.start();
        t3.start();

    }

    private static int ticket=100;
    private static Object object=new Object();

    @Override
    public void run() {

           while(true){
                sale();
           }

    }

    private  static synchronized void sale()  {

          if(ticket>0){
              try {
                  Thread.sleep(100);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              System.out.println(Thread.currentThread().getName()+",买票,票号为: "+ticket);
              ticket--;
          }

    }
}
```

关于同步方法的总结:
1.同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。
2.非静态的同步方法，同步监视器是: this,静态的同步方法，同步监视器是:当前类本身

使用同步机制将单例模式中的懒汉式改写为线程安全的

```java
package com.dreamcold.thread;

public class BankTest {
    public static void main(String[] args) {

    }
}

class Bank{
    private Bank(){

    }

    private static Bank instance=null;

    public static Bank getInstance(){
        if (instance==null){
            instance=new Bank();
            return instance;
        }
        return instance;
    }
}
```

使用同步方法来实现同步

```java
package com.dreamcold.thread;

public class BankTest {
    public static void main(String[] args) {

    }
}

class Bank{
    private Bank(){

    }

    private static Bank instance=null;

    public synchronized static Bank getInstance(){
        if (instance==null){
            instance=new Bank();
            return instance;
        }
        return instance;
    }
}

```

使用同步代码块来实现同步，方式一，直接都加到同步代码块中，效率稍微差

```java
package com.dreamcold.thread;

public class BankTest {
    public static void main(String[] args) {

    }
}

class Bank{
    private Bank(){

    }

    private static Bank instance=null;

    public static Bank getInstance(){
        //效率稍差
        synchronized (Bank.class){
            if (instance==null){
                instance=new Bank();
                return instance;
            }
            return instance;
        }
    }
}
```

方式二：简单判断，减少不必要的加锁，提高效率

```java
package com.dreamcold.thread;

public class BankTest {
    public static void main(String[] args) {

    }
}

class Bank{
    private Bank(){

    }

    private static Bank instance=null;

    public static Bank getInstance(){
       if (instance==null){
           synchronized (Bank.class){
               instance=new Bank();
               return instance;
           }
       }
       return instance;
    }
}

```

### 死锁

- 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁

- 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续

**死锁的必要条件**

- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
- 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
- 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

关于死锁的面试题:[csnote](http://cyc2018.gitee.io/cs-notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E6%AD%BB%E9%94%81)

**解决方法**

- 专门的算法、原则
- 尽最减少同步资源的定义
- 尽量避免嵌套同步

**示例一：**

```java
package com.dreamcold.thread;

public class Demo06 {
    public static void main(String[] args) {
        StringBuffer s1=new StringBuffer();
        StringBuffer s2=new StringBuffer();

        new Thread(){
            @Override
            public void run() {
                synchronized (s1){
                    s1.append("a");
                    s2.append("1");
                    synchronized (s2){
                        s1.append("b");
                        s2.append("2");
                        System.out.println(s1);
                        System.out.println(s2);
                    }
                }
            }
        }.start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (s2){
                    s1.append("c");
                    s2.append("3");
                    synchronized (s1){
                        s1.append("d");
                        s2.append("4");
                        System.out.println(s1);
                        System.out.println(s2);
                    }
                }
            }
        }).start();


    }
}
```

效果：

![image-20210204210939575](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210204210939575.png)

加上休眠后，增加了死锁的概率

```java
package com.dreamcold.thread;

public class Demo06 {
    public static void main(String[] args) {
        StringBuffer s1=new StringBuffer();
        StringBuffer s2=new StringBuffer();

        new Thread(){
            @Override
            public void run() {

                synchronized (s1){
                    s1.append("a");
                    s2.append("1");
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (s2){
                        s1.append("b");
                        s2.append("2");
                        System.out.println(s1);
                        System.out.println(s2);
                    }
                }
            }
        }.start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (s2){
                    s1.append("c");
                    s2.append("3");
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (s1){
                        s1.append("d");
                        s2.append("4");
                        System.out.println(s1);
                        System.out.println(s2);
                    }
                }
            }
        }).start();


    }
}
```

效果：

![image-20210204211245995](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210204211245995.png)



### Lock(锁)
- 从JDK 5.0开始，Java提供了更强大的线程同步机制一-通过 显式定义同
  步锁对象来实现同步。同步锁使用Lock对象充当。
- java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。
- ReentrantLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock， 可以显式加锁、释放锁。

**示例：实现窗口卖票**

```java
package com.dreamcold.thread;

import java.util.concurrent.locks.ReentrantLock;

public class Window2 implements Runnable{
    private int ticket=100;

    private ReentrantLock reentrantLock=new ReentrantLock(true);
    //如果构造器传入true就是一个公平的锁，即先进先出的特点，不写默认是false

    public static void main(String[] args) {
        Window2 window2=new Window2();
        Thread t1=new Thread(window2);
        Thread t2=new Thread(window2);
        Thread t3=new Thread(window2);
        t1.setName("t1");
        t2.setName("t2");
        t3.setName("t3");

        t1.start();
        t2.start();
        t3.start();
    }


    @Override
    public void run() {
       try {
           reentrantLock.lock();
           while (true){
               if(ticket>0){
                   try {
                       Thread.sleep(100);
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
                   System.out.println(Thread.currentThread().getName()+": 售票，票号为"+ticket);
                   ticket--;
               }else{
                   break;
               }
           }
       }finally {
            reentrantLock.unlock();
       }
    }
}
```

效果：

![image-20210206195954036](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210206195954036.png)

- 面试题: synchronized 与Lock的异同?

- 相同:二者都可以解决线程安全问题
- 不同: synchronized 机制在执行完相应的同步代码以后，自动的释放同步监视器Lock需要手动时
- Lock需要手动的启动同步(Lock())，同时结束同步也需要手动的实现(unLock() ) 

### synchronized与Lock的对比

1. Lock是显式锁(手动开启和关闭锁，别忘记关闭锁)，synchronized是
隐式锁，出了作用域自动释放
2. Lock只有代码块锁，synchronized有 代码块锁和方法锁
3. 使用Lock锁， JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性( 提供更多的子类

**优先使用顺序:**
Lock→同步代码块(已经进入了方法体，分配了相应资源) >同步方法(在方法体之外)



### 线程同步实际问题

银行有一个账户。

有两个储户分别向同一个账户存3000元，每次存1000, 存3次。每次存完打印账户余额。
问题:该程序是否有安全问题，如果有，如何解决?

[提示]

1. 明确哪些代码是多线程运行代码，须写入run()方法
2. 明确什么是共享数据。
3. 明确多线程运行代码中哪些语句是操作共享数据的。.
4. 拓展问题: :可否实现两个储户交替字钱的操作

分析:

1. 是否是多线程问题?是，两个储户线程
2. 是否有共享数据?有，账户(或账户余额)
3. 是否有线程安全问题?有
4. 需要考虑如何解决线程安全问题?同步机制:有

```java
package com.dreamcold.thread;

public class Acount {

    private double balance;

    public Acount(double balance){
        this.balance=balance;
    }

    //存钱
    public synchronized void desposit(double amt){
        if (amt>0){
            balance+=amt;
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+": 存钱成功，当前余额为"+balance);
        }
    }

    public static void main(String[] args) {
        Acount acount=new Acount(0);
        Customer c1=new Customer(acount);
        Customer c2=new Customer(acount);
        c1.setName("甲");
        c2.setName("乙");
        c1.start();
        c2.start();
    }


}

class Customer extends  Thread{
    private Acount acct;

    public Customer(Acount acct) {
        this.acct = acct;
    }

    @Override
    public void run() {
        for (int i = 0; i < 3; i++) {
            acct.desposit(1000);
        }
    }
}
```

效果：

![image-20210206203309554](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210206203309554.png)

## 线程的通信

### 线程交替打印

使用两个线程打印1-100。线程1,线程2交替打印

```java
package com.dreamcold.thread;

class Number implements Runnable{

    private int number=1;

    @Override
    public void run() {
        synchronized (this){
            while (true){
                //唤醒所有处于阻塞状态的线程
                notify();
                if (number<=100){
                    try {
                        Thread.sleep(100);//sleep方法不会释放锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName()+":"+number);
                    number++;
                    //使得当前线程变成阻塞状态
                    try {
                        wait();//wait方法会释放锁
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }else {
                    break;
                }
            }
        }
    }
}

public class CommunicationTest {
    public static void main(String[] args) {
        Number number=new Number();
        Thread t1 = new Thread(number);
        Thread t2 = new Thread(number);
        t1.setName("线程1");
        t2.setName("线程2");
        t1.start();
        t2.start();
    }
}
```

效果：

![image-20210206205339164](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210206205339164.png)

### wait与notify以及notifyAll

涉及到的三个方法:

- wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。
- notify():-旦执行此方法，就会唤醒被wait的一一个线程。 如果有多个线程被wait,就唤醒优先级高的线程
- notifyAll():一且执行此方法，就会唤醒所有被wait的线程。

注意：

1. wait(), notify(), notifyAll(三个方法必须使用在同步代码块或同步方法中。
2. wait(), notify(), notifyAll:三个方法的调用者必须是同步代码块或同步方法中的同步监视器
3. 否则，会出现IllegalMonitorStateException异常
4. wait(), notify(), notifyALl()三个方法是定义在java. lang. object类中。

### sleep()和wait()的异同

1. 相同点:一旦执行方法，都可以使得当前的线程进入阻塞状态。

2. 不同点: 1)两个方法声明的位置不同: Thread类中声明sleep()

3. object类中声明wait()
4. 调用的要求不同: sleep() 可以在任何需要的场景下调用。wait必须在同步代码块或者同步方法中调用
5. 释放锁：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁， wait() 会释放锁。



### 生产者消费者问题

- 生产者(Productor)将产品交给店员(Clerk)， 而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20)，如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产:如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。

- 这里可能出现两个问题:
  - 生产者比消费者快时，消费者会漏掉一些数据没有取到。
  - 消费者比生产者快时，消费者会取相同的数据。

分析:

1. 是否是多线程问题?是，生产者线程，消费者线程
2. 是否有共享数据?是，店员（产品）
3. 如何解决线程的安全问题，同步机制，三种方法
4. 是否涉及线程的通信?是

```java
package com.dreamcold.thread;

public class ProductorTest {
    public static void main(String[] args) {
        Clerk clerk=new Clerk();
        Producer p1=new Producer(clerk);
        p1.setName("生产者1");
        Consumer c1=new Consumer(clerk);
        c1.setName("消费者1");
        p1.start();
        c1.start();
    }
}

class Clerk{
    //产品的数量
    private int productNum=0;

    //生产产品
    public synchronized void produceProduct() {
        if (productNum<20){
            productNum++;
            System.out.println(Thread.currentThread().getName()+": 开始生产了"+productNum+"个产品");
            //生产了一个产品消费者就可以消费，唤醒消费者线程
            notify();
        }else {
            //等待
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    //消费产品
    public synchronized void consumeProduct() {
        if (productNum>0){
            System.out.println(Thread.currentThread().getName()+": 开始消费第"+productNum+"个产品");
            productNum--;
            //消费了一个元素就可以让生产者生产
            notify();
        }else {
            //等待
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

//生产者
class Producer extends Thread{
    private Clerk clerk;

    public Producer(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        System.out.println(getName()+"：开始生产产品...");
        while (true){
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            clerk.produceProduct();
        }
    }
}

class Consumer extends Thread{
    private Clerk clerk;

    public Consumer(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        System.out.println(getName()+"：开始消费产品...");
        while (true){
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            clerk.consumeProduct();
        }
    }
}
```

效果：

![image-20210206214248146](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210206214248146.png)

## JDK5.0新增线程创建方式

### 新增方式一:实现Callable接口

- 与使用Runnable相比，Callable功能更 强大些

- 相比run()方法，可以有返回值

- 方法可以抛出异常

- 支持泛型的返回值

- 需要借助FutureTask类， 比如获取返回结果

  

```java
package com.dreamcold.thread;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

class NumThread implements Callable{
    @Override
    public Object call() throws Exception {
        int sum=0;
        for (int i = 0; i <= 100; i++) {
            if(i%2==0){
                System.out.println(i);
                sum+=i;
            }
        }
        return  sum;
    }
}

public class ThreadNew {
    public static void main(String[] args) {
        NumThread numThread=new NumThread();
        FutureTask futureTask = new FutureTask(numThread);
        new Thread(futureTask).start();
        try {
            //get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值
            Object sum = futureTask.get();
            System.out.println(sum);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }

    }

}
```

效果：

![image-20210209150434695](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210209150434695.png)



### 新增方式二:使用线程池

- 背景:经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。思路:提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交
  通工具。
- 好处:
  - 提高响应速度(减少了创建新线程的时间)
  - 降低资源消耗(重复利用线程池中线程，不需要每次都创建)
  - 便于线程管理
- corePoolSize: 核心池的大小
- maximumPoolSize: 最大线程数
- ivokeepAliveTime:线程没有任务时最多保持多长时间后会终止



JDK 5.0起提供了线程池相关API: ExecutorService 和Executors
ExecutorService:真正的线程池接口。常见子类ThreadPoolExecutor

- `void execute(Runnable command)`:执行任务/命令，没有返回值，一般用来执行Runnable
- `<T> Future<T> submit(Callable<T> task)`:执行任务，有返回值，-般又来执行Callable
- `void shutdown()`:关闭连接池
- `Executors`:工具类、线程池的工厂类，用于创建并返回不同类型的线程池
- `Executors.newCachedThreadPool()`: 创建一个可根据需要创建新线程的线程池
- `Executors .newFixedThreadPool(n)`;创建一个可 重用固定线程数的线程池
- `Executors .newSingleThreadExecutor()`:创建一个只有-一个线程的线程池
- `Executors.newScheduledThreadPool(n)`: 创建一个线程池， 它可安排在给定延迟后运
  行命令或者定期地执行。

```java
package com.dreamcold.thread;

import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

class NumberThread implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i%2==0){
                System.out.println(i);
            }
        }
    }
}

public class ThreadPool {
    public static void main(String[] args) {
        ExecutorService service= Executors.newFixedThreadPool(10);
        service.execute(new NumberThread());//适合于实现Runnable对象
//        service.submit();//适合实现Callable对象
        service.shutdown();//关闭连接池
    }
}
```

效果：

![image-20210209151713403](https://gitee.com/kangyujian/notebook-images/raw/master/images/image-20210209151713403.png)