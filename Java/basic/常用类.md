# 常用类

## 字符串相关的类

### String类

- String类:代表字符串。Java 程序中的所有字符串字面值(如"abc" )都作为此类的实例实现。
- String是一个final类，代表不可变的字符序列。
- 字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改。
- String对象的字符内容是存储在一个字符数组value[]中的。
- String声明为final的，不可被继承
- String实现了Serializable接口:表示字符串可以序列化
- 实现了Comparable接口可以比较大小
- String内部定义了final char[] value用于存储字符串数据
- String代表不可变的字符序列
  - 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。
  - 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能在原有value上赋值
  - 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值,
- 通过字面量的方式(区别new)给-一个字符串赋值，此时的字符串值声明在字符事常量池中。
- 字符串常量池中是不会存储相同内容的字符串的。

<img src="images/image-20210124155658639.png" alt="image-20210124155658639" style="zoom:80%;" />

#### String的不可变性

样例一：

```java
package com.dreamcold.useful;

public class Demo01 {
    public static void main(String[] args) {
        String s1="abc";
        String s2="abc";

        System.out.println(s1==s2);//比较s1和s2的地址值
        s1="hello";
        System.out.println(s1);//hello
        System.out.println(s2);//abc
    }
}

```

效果：

![image-20210125212019661](images/image-20210125212019661.png)

- 原因：方法区中间有字符串常量池，两个变量同时指向该常量

<img src="images/image-20210125212316923.png" alt="image-20210125212316923" style="zoom:80%;" />

样例二：

```java
package com.dreamcold.useful;

public class Demo01 {
    public static void main(String[] args) {
        String s1="abc";
        String s2="abc";

        System.out.println(s1==s2);//比较s1和s2的地址值
        s1="hello";
        System.out.println(s1);//hello
        System.out.println(s2);//abc
        System.out.println("=========");
        String s3="abc";
        s3+="def";
        System.out.println("s3="+s3);
        System.out.println("s2="+s2);
    }
}
```

效果：s2并没有改变，得出结论当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能在原有value上赋值

![image-20210125213407753](images/image-20210125213407753.png)

样例三：

```java
package com.dreamcold.useful;

public class Demo03 {
    public static void main(String[] args) {
        String s1="abc";
        String s2=s1.replace('a','m');
        System.out.println("s1="+s1);
        System.out.println("s2="+s2);
    }
}
```

结果：当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值,

![image-20210125213812719](images/image-20210125213812719.png)



#### String对象的创建

```java
String str = "he1lo";
//本质上.this.value = new char[0];
String s1 = new String();
//this.value = original. value;
String s2 = new String(String original);
//this.value = Arrays . copy0f(value, value. length) ;
String s3 = new String(char[] a);
String s4 = new String(char[] a,int startIndex,int count);
```

样例一：

```java
package com.dreamcold.useful;

public class Demo04 {
    public static void main(String[] args) {
        //通过字面量定义的方式:此时的s1和s2的数据javaEE声明在方法区中的字符串常量池中。
        String s1="javaEE";
        String s2="javaEE";
        //通过new +构造器的方式:此时的s3和Is4保存的地址值，是数据在堆空间中开辟空间保存的地址值
        String s3=new String("javaEE");
        String s4=new String("javaEE");
        System.out.println(s1==s2);
        System.out.println(s1==s3);
        System.out.println(s1==s4);
        System.out.println(s3==s4);
    }
}
```

效果：

![image-20210125214941940](images/image-20210125214941940.png)

样例二：

Person.java

```java
package com.dreamcold.useful;

public class Person {
    String name;
    int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Person() {
    }
}
```

Demo05.java

```java
package com.dreamcold.useful;

public class Demo05 {
    public static void main(String[] args) {
        Person p1=new Person("Tom",12);
        Person p2=new Person("Tom",12);
        System.out.println(p1.name.equals(p2.name));
        System.out.println(p1.name==p2.name);
    }
}
```

效果：

![image-20210125215628188](images/image-20210125215628188.png)

原因内存示意图：

<img src="images/image-20210125215713147.png" alt="image-20210125215713147" style="zoom:80%;" />

- 面试题: String s = new string( "abc");方式创建对象，在内存中创建了几个对象?
- 回答：两个，包含堆中new出来的对象，以及常量池中的对象

样例三：拼接的方式

```java
package com.dreamcold.useful;

public class Demo06 {
    public static void main(String[] args){
        String s1="javaEE";
        String s2="hadoop";

        String s3="javaEEhadoop";
        String s4="javaEE"+"hadoop";
        String s5=s1+"hadoop";
        String s6="javaEE"+s2;
        String s7=s1+s2;
        System.out.println(s3==s4);
        System.out.println(s3==s5);
        System.out.println(s3==s6);
        System.out.println(s5==s6);
        System.out.println(s3==s7);
        System.out.println(s5==s7);
    }
}
```

结果：

<img src="images/image-20210127195806906.png" alt="image-20210127195806906" style="zoom:80%;" />

结论:

- 常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。T
- 只要其中有一个是变量，结果就在堆中
- 如果拼接的结果调用intern()方法，返回值就在常量池中

<img src="images/image-20210127195940831.png" alt="image-20210127195940831" style="zoom:80%;" />

```java
///返回值得到的s8使用的常量值中已经存在的"javaEEhadoop"
String s8=s5.intern();
```

#### JVM中涉及String

![image-20210127200317678](images/image-20210127200317678.png)

**三种JVM**

- Sun公司的HotSpot
- BEA公司的JRockit
- IBM公司的J9 VM

**堆内存示意图**

![image-20210127200518863](images/image-20210127200518863.png)

**Heap堆**
一个JVM实例只存在一个堆内存,堆内存的大小是可以调节的。类。加载器读取了类文件后 ,需要把类. 方法、常变量放到堆内存中 ,保存所有引用类型的真实信息，以方便执行器执行,堆内存分为三部分:

![image-20210127200619146](images/image-20210127200619146.png)

**常量池的位置随着版本的变化**

![image-20210127200802929](images/image-20210127200802929.png)

![image-20210127200839148](images/image-20210127200839148.png)

![image-20210127200909074](images/image-20210127200909074.png)

#### String常用的方法

````java
int length()//:返回字符串的长度: return value.length
char charAt(int index)//:返回某索 引处的字符return value[index]
boolean isEmpty()//:判断是否是空字符串: return value.length == 0
String toLowerCase()//:使用默认语言环境，将String中的所有字符转换为小写
String toUpperCase()//:使用默认语言环境，将String中的所有字符转换为大写
String trim()//:返回字符串的副本，忽略前导空白和尾部空白
boolean equals(Object obj)//:比较字符串的内容是否相同
boolean equalslgnoreCase(String anotherString)//:与equals方法类似， 忽略大
小写
String concat(String str)//:将指定字符串连接到此字符串的结尾。等价于用“+”
int compareTo(String anotherString)//:比较两 个字符串的大小
String substring(int beginIndex)//: 返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。
String substring(int beginIndex, int endIndex) //:返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。

````

示例一:

```java
package com.dreamcold.useful;

public class Demo07 {
    public static void main(String[] args) {
        String s1="HelloWorld";
        System.out.println(s1.length());
        System.out.println(s1.charAt(0));
        System.out.println(s1.charAt(9));

        System.out.println(s1.isEmpty());

        String s2= s1.toLowerCase();
        System.out.println(s1);//s1不可变的，仍然为原来的字符串

        System.out.println(s2);//改写为小写

        String s3=" he llo world    ";
        String s4=s3.trim();
        System.out.println("======="+s3+"======");
        System.out.println("======="+s4+"======");
        
    }
}
```

效果：

<img src="images/image-20210127201723826.png" alt="image-20210127201723826" style="zoom:80%;" />



示例二：忽略大小写比较

```java
package com.dreamcold.useful;

public class Demo08 {
    public static void main(String[] args) {
        String s1="HelloWorld";
        String s2="helloworld";
        System.out.println(s1.equals(s2));
        System.out.println(s1.equalsIgnoreCase(s2));
    }
}
```

示例三：字符串拼接

```java
package com.dreamcold.useful;

public class Demo08 {
    public static void main(String[] args) {
        String s3="abc";
        String s4=s3.concat("def");
        System.out.println(s4);
    }
}

```

![image-20210127202053747](images/image-20210127202053747.png)

示例四：字符串比较

```java
package com.dreamcold.useful;

public class Demo09 {
    public static void main(String[] args) {
        String s1="abc";
        String s2="abd";
        System.out.println(s1.compareTo(s2));
    }
}
```

- 大于为1
- 小于为-1
- 等于为0
- 按照字母的顺序进行比较排序

![image-20210127202259731](images/image-20210127202259731.png)

示例五：字符串切片

```java
package com.dreamcold.useful;

public class Demo10 {
    public static void main(String[] args) {
        String name="dreamcold";
        System.out.println(name.substring(0,3));
    }
}

```

效果：

![image-20210127202504979](images/image-20210127202504979.png)

注意：区间为[a,b)

```java
boolean endsWith(String suffx)//:测试此字符串是否以指定的后缀结束
boolean startsWith(String prefix)//: 测试此字符串是否以指定的前缀开始
boolean startsWith(String prefix, int toffset)//: 测试此字符串从指定索引开始的子字符串是否以指定前缀开始
```

示例六：以某种字符串开头

```java
package com.dreamcold.useful;

public class Demo11 {
    public static void main(String[] args) {
        String str1="helloworld";
        System.out.println(str1.endsWith("ld"));
    }
}

```

效果：

![image-20210127202900156](images/image-20210127202900156.png)

示例七：以某个字符串开头

```java
package com.dreamcold.useful;

public class Demo12 {
    public static void main(String[] args) {
        String s="helloworld";
        System.out.println(s.startsWith("he"));
    }
}
```

效果：

![image-20210127203043322](images/image-20210127203043322.png)

```java
boolean contains(CharSequence s)//: 当且仅当此字符串包含指定的char值序列时，返回true
int indexOf(String str)//:返回指定子字符串在此字符串中第一次 出现处的索引
int indexOf(String str, int fromIndex)//:返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始
int lastiIndexOf(String str)//:返回指定子字符串在此字符串中最右边出现处的索引
int lastlndexOf(String str, int fromIndex)//:返回指定子字符串在此字符串中最后次出现处的索引， 从指定的索引开始反向搜索
//注: indexOf 和lastlndexOf方法如果未找到都是返回-1 ]
```

示例八：是否包含该字符串

```java
package com.dreamcold.useful;

public class Demo13 {
    public static void main(String[] args) {
        String s1="HelloWorld";
        System.out.println(s1.contains("He"));
    }
}
```

效果：

![image-20210127203337918](images/image-20210127203337918.png)

示例九：判断字符串在该字符串中出现的索引

```java
package com.dreamcold.useful;

public class Demo14 {
    public static void main(String[] args) {
        String s="HelloWorld";
        System.out.println(s.indexOf('a'));
        System.out.println(s.indexOf('H'));
        System.out.println(s.indexOf("He"));

    }
}
```

效果：

![image-20210127204507942](images/image-20210127204507942.png)

示例十：

```java
package com.dreamcold.useful;

public class Demo15 {
    public static void main(String[] args) {
        String s="HelloWorld";
        System.out.println(s.lastIndexOf("ld"));
    }
}
```

效果：

![image-20210127205005087](images/image-20210127205005087.png)



```java
String replace(char oldChar, char newChar)//:返回一个新的字符串，它是通过用newChar替换此字符串中出现的所有oldChar得到的。
String replace(CharSequence target, CharSequence replacement)//: 使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。
String replaceAll(String regex, String replacement)// :使用给定的replacement替换此字符串所有匹配给定的正则表达式的子字符串。
String replaceFirst(String regex, String replacement)//: 使用给定的replacement替换此字符串匹配给定的正则表达式的第一个 子字符串。

```

示例十二：字符串替换

```java
package com.dreamcold.useful;

public class Demo16 {
    public static void main(String[] args) {
        String str1="我想学Java";
        String str2=str1.replace('我','你');
        System.out.println(str1);
        System.out.println(str2);
        String str3=str1.replace("Java","Python");
        System.out.println(str3);
        
    }
}
```

效果：

![image-20210127205911625](images/image-20210127205911625.png)

示例十三：正则表达式匹配与替换

```java
package com.dreamcold.useful;

public class Demo17 {
    public static void main(String[] args) {
        String str="12345";
        //判断str字符是不是全部由数字组成，即由1-n中的数字组成
        boolean matches=str.matches("\\d+");
        System.out.println(matches);
        //判断是杭州的电话号码
        String tel="0571-4534289";
        boolean result=tel.matches("0571-\\d{7,8}");
        System.out.println(result);
    }
}
```

效果：

![image-20210127210516177](images/image-20210127210516177.png)



#### 字符串与其他类型进行转化

- 字符串>基本数据类型、包装类
  - Integer包装类的public static int parselnt(String s):可以将由“数字”字
    符组成的字符串转换为整型。
  - 类似地,使用java.lang包中的Byte、Short、 Long、 Float、 Double 类调相应的类方法可以将由“数字”字符组成的字符串，转化为相应的基本数据类型。
- 基本数据类型、包装类>字符串
  - 调用String类的public String valueOf(int n)可将int型转换为字符串
  - 相应的valueOf(byte b)、valueOf(long)、valueOf(float f)、valueOf(double
  - valueOf(boolean b)可由参数的相应类型到字符串的转换

示例一：字符串与其他类型进行转换

```java
package com.dreamcold.useful;

public class Demo18 {
    public static void main(String[] args) {
        String str1="123";
        int num=Integer.parseInt(str1);
        String strnum=String.valueOf(num);
        System.out.println(strnum);
        String strnum1=num+"";
        System.out.println(strnum1);
    }
}
```

效果：

![image-20210127211224652](images/image-20210127211224652.png)

#### String与字符数组的转换

```java
package com.dreamcold.useful;

public class Demo19 {
    public static void main(String[] args) {
        String str1="abc123";
        char[] charArray=str1.toCharArray();
        for (int i = 0; i < charArray.length; i++) {
            System.out.println(charArray[i]);
        }
        char[] chars=new char[]{'H','l','l','o'};
        String sc=new String(chars);
        System.out.println(sc);
    }
}
```

效果：

![image-20210127211549992](images/image-20210127211549992.png)



#### String与byte数组转换

- public bytegetBytes() :使用平台的默认字符集将此String编码为
- byte序列，并将结果存储到-一个新的byte数组中。
- public byte[] getBytes(String charsetName) :使用指定的字符集将
- 此String编码到byte序列，并将结果存储到新的byte数组。

示例一:字符串转bytes数组

```java
package com.dreamcold.useful;

import java.util.Arrays;

public class Demo20 {
    public static void main(String[] args){
        String str="abc123";
        byte[] bytes=str.getBytes();
        System.out.println(Arrays.toString(bytes)
    }
}
```

![image-20210128112230804](images/image-20210128112230804.png)

示例二：字符串转byte数组带编码

- 编码:字符串-->字节(看得懂--->看不懂的二进制数据)
- 解码:编码的逆过程，字节-->字符串

```java
package com.dreamcold.useful;

import java.io.UnsupportedEncodingException;
import java.util.Arrays;

public class Demo20 {
    public static void main(String[] args) throws UnsupportedEncodingException {
        String str="abc123你好世界";
        byte[] bytes=str.getBytes();
        System.out.println(Arrays.toString(bytes));
        byte[] gbks=str.getBytes("gbk");
        System.out.println(Arrays.toString(gbks));
    }
}
```

效果：

![image-20210128112626387](images/image-20210128112626387.png)

示例三：byte数组转化为字符串

```java
package com.dreamcold.useful;

import java.io.UnsupportedEncodingException;
import java.util.Arrays;

public class Demo20 {
    public static void main(String[] args) throws UnsupportedEncodingException {
        String str="abc123你好世界";
        byte[] bytes=str.getBytes();
        String str2=new String(bytes);
        System.out.println(str2);
    }
}
```

效果：

![image-20210128112916505](images/image-20210128112916505.png)

示例四：根据具体的字符集将byte数组转化为字符串

```java
package com.dreamcold.useful;

import java.io.UnsupportedEncodingException;

public class Demo21 {
    public static void main(String[] args) throws UnsupportedEncodingException {
        String str="abc123你好世界";
        byte[] bytes=str.getBytes("gbk");
        System.out.println("按照默认编码");
        String str1=new String(bytes);
        System.out.println(str1);
        System.out.println("按照指定编码");
        String str2=new String(bytes,"gbk");
        System.out.println(str2);

    }
}
```

效果：

![image-20210128113302450](images/image-20210128113302450.png)



### StringBuffer类

#### 简介

- java.lang.StringBuffer代表可变的字符序列，JDK1.0中声明， 可以对字符串内容进行增删，此时不会产生新的对象。
- 很多方法与String相同。
- 作为参数传递时，方法内部可以改变值。

![image-20210128113928598](images/image-20210128113928598.png)

#### StringBuffer与StringBuilder以及String的区别

- StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样
- 面试题:对比String、StringBuffer、 StringBuilder

  - String(JDK1.0):不可变字符序列，底层用char[]来存储
  - StringBuffer(JDK1.0): 可变字符序列、效率低、线程安全，底层用char[]来存储
  - StringBuilder(JDK 5.0):底层用char[]来存储、可变字符序列、效率高、线程不安全



#### StringBuffer是可变的

```java
package com.dreamcold.useful;

public class Demo22 {
    public static void main(String[] args) {
        StringBuffer sb1=new StringBuffer("abc");
        sb1.setCharAt(0,'m');
        System.out.println(sb1);
    }
}
```

效果：

![image-20210128114550139](images/image-20210128114550139.png)

#### StringBuffer的源码分析

```java
String str = new String();//new char[e];
String str1 = new String( "abc");//new char[]{'a', 'b', 'c'};
StringBuffer sb1 = new StringBuffer();//new char[16]; 底层创建了一个长度是16的数组。
sb1. append( 'a')://value[e] ='a';
sb1. append( 'b ');//value[1] ='b';
StringBuffer sb2=new StringBuffer( "abc");//char[] value = new char[ "abc ".length()+ 16]
//问题1. System. out. println(sb2. Length());//3 
//问题2.扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。
//扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。
//默认情况下，扩容为原来容量的2倍+ 2,同时将原有数组中的元素复制到新的数组中。
//指导意义:开发中建议大家使用: StringBuffer(int capacity) 或StringBu[ffer(int capacity)|

```

#### StrinBuffer类中的常用方法

```java
//public int indexOf(String str)
//public String substring(int startint end)
//public int length() 
//public char charAt(int n )
//public void setCharAt(int n ,char ch)
//StringBuffer append(xxx): 提供了很多的append()方法，用于进行字符串拼接
//StringBuffer delete(int start, int end): 删除指定位置的内容
//StringBuffer replace(int start, int end, String str): 把[start, end)位置普换为str
//StringBuffer insert(int offset, xxx): 在指定位置插入xxx
//StringBuffer reverse() :把当前字符序列逆转
//public int indexOf(String str)
//public String substring(int start, int end)
//public int Length()
//public char charAt(int n )
//public void setCharAt(int n , char ch)
```

#### StringBuffer中的API调用

```java
package com.dreamcold.useful;

public class Demo23 {
    public static void main(String[] args) {
        StringBuffer s1=new StringBuffer("abc");
        s1.append(1);
        s1.append("1");
        System.out.println(s1);
        s1.delete(2,4);
        s1.insert(2,false);
        System.out.println(s1);
        System.out.println(s1.length());
    }
}
```

效果：

![image-20210128115831949](images/image-20210128115831949.png)

总结：
```java
// 增: append(xxx)
// 删: delete(int start, int end)
// 改: setCharAt(int n ,char ch) / replace(int start, int end, String str)
// 查: charAt(int n )
// 插: insert(int offset, xxx)
// 长度: Length();
// 遍历: for+charAt()+toString()
```


## JDK8之前日期相关的类

### JDK8之前日期时间API

![image-20210128120253085](images/image-20210128120253085.png)

### java.lang.System类

- System类提供的public statlc long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。
  - 此方法适于计算时间差。
- 计算世界时间的主要标准有:
  - UTC(Coordinated Universal Time)
  - GMT(Greenwich Mean Time)
  - CST(Central Standard Time)

示例一：

```java
long time=System.currentTimeMillis();
//返回当前时间与1970年1月1日θ时0分日秒之间以毫秒为单位的时间差。
System.out.println(time);
```

计算时间差：

![image-20210128140912768](images/image-20210128140912768.png)

### java.util.Date类

- 构造器:
  - Date(): 使用无参构造器创建的对象可以获取本地当前时间。
  - Date(long date)
 - 常用方法
     - getTime():返回自 1970年1月1日00:00:00 GMT以来此Date对象表示的毫秒数。
     - toString():把此 Date对象转换为以下形式的String: dow mon dd
     - hh:mm:ss zz yyyy其中: dow 是一周中的某一 天(Sun, Mon, Tue,Wed, Thu, Fri, Sat)，zzz 是时间标准。
     - 其它很多方法都过时了。

示例一：构造器的使用

```java
Date data1=new Date();
System.out.println(data1.toString());
```

效果：显示当前的年、月、日、时、分、秒

![image-20210128141454661](images/image-20210128141454661.png)

示例二：获取时间戳

```java
Date data1=new Date();
System.out.println(data1.getTime());
```

效果：

![image-20210128141850721](images/image-20210128141850721.png)

示例三：创建指定毫秒数的Date对象

```java
Date data1=new Date();
System.out.println(data1.getTime());
long time=data1.getTime();
Date data2=new Date(time);
System.out.println(data2);
```

效果：

![image-20210128142054332](images/image-20210128142054332.png)



### java.sql.Date类

java.sql.Date对应者数据宰中的日期类型的变量

示例一：对象的创建

```java
java.sql.Date date=new java.sql.Date(1611814831401L);
System.out.println(date);
```

效果：

![image-20210128142602698](images/image-20210128142602698.png)

示例二：如何将util. Date对象转换为sql. Date对象

```java
Date date=new Date();
java.sql.Date data2=new java.sql.Date(date.getTime());
System.out.println(data2.toString());
```

效果：

![image-20210128143213197](images/image-20210128143213197.png)

### java.text.SimpleDateFormat类

- Date类的API不易于国际化，大部分被废弃了I，java.text.SimpleDateFormat
- 类是一个不与语言环境有关的方式来格式化和解析日期的具体类。
- 它允许进行格式化:日期>文本、解析:文本>日期
- 格式化:
  - SimpleDateFormat() :默认的模式和语言环境创建对象
  - public SimpleDateFormat(String pattern):该构造方法可以用参数patte
  - 指定的格式创建一一个对象，该对象调用:
  - public String format(Date date):方法格式化时间对象date
- 解析:
  - public Date parse(String source):从给定字符串的开始解析文本，以生成一个日期。



示例一：

- 格式化:日期--->字符串

- 解析:格式化的逆过程，字符串--->日期

```java
package com.dreamcold.useful;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class Demo27 {
    public static void main(String[] args) throws ParseException {
        //实例化 SimpleDateFormat
        SimpleDateFormat sdf=new SimpleDateFormat();
        //格式化：日期--->字符串
        Date date=new Date();
        System.out.println(date);
        String format=sdf.format(date);
        System.out.println(format);
//        //解析：格式化的逆过程，字符串--->日期
//        String str="2019-08-09";
//        Date date1= sdf.parse(str);
//        System.out.println(date1);
//解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现)
        SimpleDateFormat sdf1=new SimpleDateFormat("yyyy.MMMMM.dd GGG hh:mm:aaa");
        String format1=sdf.format(date);
        System.out.println(format1);

    }
}
```

效果：

![image-20210128145351210](images/image-20210128145351210.png)

另外一种常用的格式为：

```java
SimpleDateFormat sdf1=new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
```

解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现)

p:481,00:52



## JDK8中新的日期相关的API



## Java比较器



## System类



## Math类



## BigInteger和BigDecimal

