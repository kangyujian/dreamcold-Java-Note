# 泛型

## 什么是泛型

泛型将接口的概念进一步延伸， “泛型”的字面意思就是广泛的类型。类、接口和方法代码可以应用于
非常广泛的类型，代码与它们能够操作的数据类型不再绑定在一起，同一套代码可以用于多种数据类型,
这样，不仅可以复用代码，降低耦合，而且可以提高代码的可读性和安全性。

示例1

```java
class Pair<T>{
    T first;
    T second;

    public Pair(T first, T second) {
        this.first = first;
        this.second = second;
    }

    public T getFirst() {
        return first;
    }

    public T getSecond() {
        return second;
    }

    public void setFirst(T first) {
        this.first = first;
    }

    public void setSecond(T second) {
        this.second = second;
    }
}
```

Pair就是一一个泛型类，与普通类的区别体现在:

- 类名后面多了一个`T`
- first和second的类型都是T

T是什么呢? T表示类型参数，泛型就是类型参数化，处理的数据类型不是固定的，而是可以作为参数传入。怎么用这个泛型类，并传递类型参数呢?看代码: 

```java
package com.dreamcold.generic;

public class Demo01 {
    public static void main(String[] args) {
        Pair<Integer> minmax=new Pair<>(1,100);
        Integer min=minmax.getFirst();
        Integer max=minmax.getSecond();
        System.out.println(min);
        System.out.println(max);
    }
}

class Pair<T>{
    T first;
    T second;

    public Pair(T first, T second) {
        this.first = first;
        this.second = second;
    }

    public T getFirst() {
        return first;
    }

    public T getSecond() {
        return second;
    }

    public void setFirst(T first) {
        this.first = first;
    }

    public void setSecond(T second) {
        this.second = second;
    }
}

```



结果

<img src="images/image-20201201182829482.png" alt="image-20201201182829482" style="zoom:80%;" />

Pair`<Integer>`中的Integer就是传递的实际类型参数。Pair类的 代码和它处理的数据类型不是绑定的，
具体类型可以变化。上面是Integer, 也可以是String,比如:

```java
 Pair<String> pair=new Pair<>("name","dreamcold");
```

类型参数可以有多个，Pair类中的first和second可以是不同的类型，多个类型之间以逗号分隔，来看改
进后的Pair类定义:

示例二

```java
package com.dreamcold.generic;

public class Demo01 {
    public static void main(String[] args) {
        Pair<String,Integer> pair=new Pair<>("id",123);
        System.out.println(pair.getFirst());
        System.out.println(pair.getSecond());
    }
}

class Pair<U,V>{
    U first;
    V second;

    public Pair(U first, V second) {
        this.first = first;
        this.second = second;
    }

    public U getFirst() {
        return first;
    }

    public V getSecond() {
        return second;
    }

    public void setFirst(U first) {
        this.first = first;
    }

    public void setSecond(V second) {
        this.second = second;
    }
}

```

结果

<img src="images/image-20201201183415392.png" alt="image-20201201183415392" style="zoom:80%;" />

`<String，Integer> `既出现在了声明变量时，也出现在了new后面，比较烦琐，从Java 7开始，支持省略
后面的类型参数，可以如下使用:

```java
Pair<String,Integer> pair=new Pair<>("id",123);
```



## 泛型的基本原理

泛型类型参数到底是什么呢?为什么一-定要定 义类型参数呢?定义普通类，直接使用Object不就行了吗?比如，Pair类可以写为:

```java
package com.dreamcold.generic;

public class Demo01 {
    public static void main(String[] args) {
        Pair pair=new Pair("123",5);
        System.out.println(pair.getFirst());
        System.out.println(pair.getSecond());
    }
}

class Pair{
   Object first;
   Object second;

    public Pair(Object first, Object second) {
        this.first = first;
        this.second = second;
    }

    public Object getFirst() {
        return first;
    }

    public Object getSecond() {
        return second;
    }

    public void setFirst(Object first) {
        this.first = first;
    }

    public void setSecond(Object second) {
        this.second = second;
    }
}

```

结果

<img src="images/image-20201201183957012.png" alt="image-20201201183957012" style="zoom:80%;" />

使用Pair的代码可以为:

```java
package com.dreamcold.generic;

public class Demo01 {
    public static void main(String[] args) {
        Pair pair=new Pair(1,100);
        Integer min=(Integer)pair.getFirst();
        Integer max=(Integer)pair.getSecond();
        System.out.println(min);
        System.out.println(max);
        Pair kv=new Pair("123",3);
        String first=(String)kv.getFirst();
        Integer second=(Integer)kv.getSecond();
        System.out.println(first);
        System.out.println(second);

    }
}
```

结果

<img src="images/image-20201201184516632.png" alt="image-20201201184516632" style="zoom:67%;" />

这样是可以的。实际上，Java泛型的内部原理就是这样的。

我们知道，Java 有Java编译器和Java虚拟机，编译器将Java源代码转换为.class文件，虚拟机加载并运
行.class文件。对于泛型类，Java编译器会将泛型代码转换为普通的非泛型代码，就像上面的普通Pair类代
码及其使用代码一样，将类型参数T擦除，替换为Object,插入必要的强制类型转换。Java虚拟机实际执
行的时候，它是不知道泛型这回事的，只知道普通的类及代码。

<img src="images/image-20201201184714960.png" alt="image-20201201184714960" style="zoom:50%;" />

再强调一~下，Java泛型是通过擦除实现的，类定义中的类型参数如T会被替换为Object,在程序运行
过程中，不知道泛型的实际类型参数，比如Pair`<Integer>`，运行中只知道Pair,而不知道Integer。认识到
这一点是非常重要的，它有助于我们理解Java泛型的很多限制。

Java为什么要这么设计呢?泛型是Java 5以后才支持的，这么设计是为了兼容性而不得已的一个选
择。

## 泛型的好处

既然只使用普通类和Object就可以，而且泛型最后也转换为了普通类，那为什么还要用泛型呢?或者
说，泛型到底有什么好处呢?泛型主要有两个好处:

- 更好的安全性
- 更好的可读性

语言和程序设计的一个重要目标是将bug尽量消灭在摇篮里，能消灭在写代码的时候，就不要等到代
码写完程序运行的时候。只使用Object， 代码写错的时候，开发环境和编译器不能帮我们发现问题，看代
码:

<img src="images/image-20201201185932490.png" alt="image-20201201185932490" style="zoom:50%;" />

编译器并没有给我报错，但是实际运行，类型转换出错

<img src="images/image-20201201190019655.png" alt="image-20201201190019655" style="zoom:50%;" />

看出问题了吗?写代码时不小心把类型弄错了，不过，代码编译时是没有任何问题的，但运行时程
序抛出了类型转换异常ClassCastException。 如果使用泛型，则不可能犯这个错误，比如下面的代码:

```java
package com.dreamcold.generic;

public class Demo01 {
    public static void main(String[] args) {
       Pair<String ,Integer> pair=new Pair<>("id",5);
       Integer id=pair.getFirst();
       String number=pair.getSecond();
    }
}

class Pair<U,V>{
    U first;
    V second;

    public Pair(U first, V second) {
        this.first = first;
        this.second = second;
    }

    public U getFirst() {
        return first;
    }

    public void setFirst(U first) {
        this.first = first;
    }

    public void setSecond(V second) {
        this.second = second;
    }

    public V getSecond() {
        return second;
    }
}
```

<img src="images/image-20201201190341980.png" alt="image-20201201190341980" style="zoom:50%;" />

IDEA会为我们报这样一个错误的同时编译会报错

<img src="images/image-20201201190430096.png" alt="image-20201201190430096" style="zoom:50%;" />

开发环境(如Eclipse) 会提示类型错误，即使没有好的开发环境，编译时Java编译器也会提示。这称
之为类型安全，也就是说，通过使用泛型，开发环境和编译器能确保不会用错类型，为程序多设置一道安
全防护网。使用泛型，还可以省去烦琐的强制类型转换，再加上明确的类型信息，代码可读性也会更好。