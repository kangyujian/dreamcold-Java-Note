# 面向对象

Java的核心思想就是OOP

## 初识面向对象

### 面向过程

1. 步骤清晰简单，第一步做什么，第二步做什么.... .
2. 面对过程适合处理一些较为简单的问题

### 面向对象

1. 物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类,然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。
2. 面向对象适合处理复杂的问题，适合处理需要多人协作的问题!

对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作,仍然需要面向过程的思路去处理。

### 什么是面向对象

面向对象编程(Object-Oriented Programming, OOP)
面向对象编程的本质就是:以类的方式组织代码，以对象的组织(封装)数据。



抽象：比如要设计一个学生管理系统，我们要将学生的共性抽离出来，比如年龄、性别、班级等等



三大特性:

- 封装：将数据包装起来，仅仅提供接口来访问数据
- 继承：儿子会继承父亲的所有东西，有子类和父类，子类通过继承父类可以得到父类的所有东西
- 多态：都是学习的方法，人可以学习，假如小明学习比较好，小红学习比较差，两者都会执行学习的方法，但是学出来的东西完全不同，同一事物多种形态

人认识论角度考虑是先有对象后有类。对象，是具体的事物。类,是抽象的，是对对象的抽象
人代码运行角度考虑是先有类后有对象。类是对象的模板。

## 方法回顾和加深

### 方法的定义

- 方法就是我们在面向过程语言中学过的函数，但是将函数写在类中就叫做方法
- main方法是整个程序的启动入口，一个真正的程序中仅仅有一个main方法

``` 
访问修饰符 返回值 函数名（...方法参数）{
	//方法体
	//返回值
}
```



#### 修饰符

Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。

- **default** (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。
- **private** : 在同一类内可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**
- **public** : 对所有类可见。使用对象：类、接口、变量、方法
- **protected** : 对同一包内的类和所有子类可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**。

| 修饰符      | 当前类 | 同一包内 | 子孙类(同一包) | 子孙类(不同包)                                               | 其他包 |
| :---------- | :----- | :------- | :------------- | :----------------------------------------------------------- | :----- |
| `public`    | Y      | Y        | Y              | Y                                                            | Y      |
| `protected` | Y      | Y        | Y              | Y/N（[说明](https://www.runoob.com/java/java-modifier-types.html#protected-desc)） | N      |
| `default`   | Y      | Y        | Y              | N                                                            | N      |
| `private`   | Y      | N        | N              | N                                                            | N      |

#### 返回类型

```java
public int max(int a,int b){
    return a>b?a:b;
}
```

声明的返回类型与实际的返回类型要一致

#### break和return的区别

| break      | return   |
| ---------- | -------- |
| 跳出switch | 结束方法 |
| 结束循环   | 返回结果 |

#### 方法名

注意规范、见名知意

#### 参数列表

1. （参数类型，参数名）...
2. 通过...来声明可变长参数

#### 方法的重载

1. 方法重载是指多个方法的方法名相同，但各自的参数不同；

2. 重载方法应该完成类似的功能，参考`String`的`indexOf()`；

3. 重载方法返回值类型应该相同。
4. 重载的方法会根据传入的参数来匹配决定究竟调用哪一个方法

### 方法的调用

#### 静态方法

即加了static的方法，假如学生类中定义说话方法

```java
package com.dreamcold.oop;

public class Student {
    public static void say(){
        System.out.println("say...");
    }
}
```

通过类名.方法名调用

```java
package com.dreamcold.oop;

public class Demo01 {
    public static void main(String[] args) {
        Student.say();
    }
}
```



#### 非静态方法

没有加static的方法,例子如下：

```java
package com.dreamcold.oop;

public class Student {
    public  void say(){
        System.out.println("say...");
    }
}

```

通过类实例化对象，再通过对象调用该方法

1. 对象类型 对象名称=new 对象名()
2. 对象名称.调用方法

```java
package com.dreamcold.oop;

public class Demo01 {
    public static void main(String[] args) {
        Student student=new Student();
        student.say();
    }
}
```

**注意**

1. 静态方法（Static Method）与静态成员变量一样，属于类本身，在类装载的时候被装载到内存（Memory），不自动进行销毁，会一直存在于内存中，直到`JVM`关闭。
2. 非静态方法（Non-Static Method）又叫实例化方法，属于实例对象，实例化后才会分配内存，必须通过类的实例来引用。不会常驻内存，当实例对象被`JVM` 回收之后，也跟着消失。
3. 静态方法只能访问静态成员和方法，非静态方法都可以访问；
4. 静态方法不能标记为override，导致派生类不能重写，但是可以访问；
5. 静态方法不能（直接）调用非静态变量，非静态方法可以引用静态变量。
6. 静态方法不属于对象，是属于类的，不需要实例化；
7. 而非静态变量是属于对象的，需要先实例化。
8. 静态方法不可以调用非静态方法

#### 形参和实参

1. 实际参数和形式参数要一一对应
2. 形式参数仅仅是参数的名字，实际参数才是真正的值

#### 值传递和引用传递

值传递

```java
package com.dreamcold.oop;

public class Demo01 {
    public static void main(String[] args) {
        int a=5;
        System.out.println("begin...");
        System.out.println(a);
        change(a);
        System.out.println("afetr...");
        System.out.println(a);
    }

    public static void change(int a){
        System.out.println(a);
    }
}

```

结果

<img src="images/image-20201119201142903.png" alt="image-20201119201142903" style="zoom:80%;" />

引用传递：传递的是对象，本质还是值传递

```java
package com.dreamcold.oop;

public class Demo01 {
    public static void main(String[] args) {
       Person person=new Person();
        System.out.println(person.name);
        System.out.println("before...");
        change(person);
        System.out.println("afetr...");
        System.out.println(person.name);
    }

    public static void change(Person person){
        person.name="dreamcold";
    }


}

class Person{
    String name;
}
```

结果：

<img src="images/image-20201119201707797.png" alt="image-20201119201707797" style="zoom:80%;" />

引用传递传递的实际上是对象的地址



## 类和对象的创建

### 类和对象的区别

类是一种抽象的数据类型,它是对某一类事物整体描述/定义,但是并不能代表某一个具体的事物.

- 动物、植物、手机、电脑....
- Person类. Pet类、 Car类等, 这些类都是用来描述/定义某-类具体的事物应该具备的特
  点和行为

对象是抽象概念的具体实例

- 张三就是人的一个具体实例，张三家里的旺财就是狗的一个具体实例。
- 能够体现出特点展现出功能的是具体的实例,而不是抽象的概念



### 创建和初始化对象

#### 使用new来创建对象

1. 使用new关键字创建的时候，除了分配内存空间之外，还会给创建好的对象进行默认的初始化
   以及对类中构造器的调用。
2. 类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下俩
   个特点:

- 必须和类的名字相同

- 必须没有返回类型,也不能写void

### 构造器详解

1. 一个类即使什么都不写，也会生成一个构造器
2. 一旦你自己定义了构造方法，那么系统就不会为你自动生成构造器
3. 构造器可以初始化对象
4. 一旦构造看了有参数构造器，但是系统就不会为你生成无参数构造器，需要你自己去定义无参数的构造器
5. 建议一旦定义有参构造器，同时也要写无参数构造器
6. 使用new关键字本质是在调用构造器，构造器是用来对对象来进行初始化的
7. IDEA中alt+insert可以快速生成构造器和getter和setter方法



### 创建对象的内存分析

1. 创建宠物类

```java
package com.dreamcold.oop;

public class Pet {
    public String name;
    public int age;

    public void shout(){
        System.out.println("shout .....");
    }
}
```

2. 创建宠物对象，调用各种方法

```java
package com.dreamcold.oop;
public class Demo02 {
    public static void main(String[] args) {
        Pet dog=new Pet();
        dog.name="wangcai";
        dog.age=12;
        dog.shout();
        System.out.println(dog.name);
        System.out.println(dog.age);
    }
}
```

3. 内存区可以分为堆、栈、方法区

![image-20201119204955740](images/image-20201119204955740.png)

4. 调用main方法压栈

![image-20201119205045496](images/image-20201119205045496.png)

5. 创建pet类加载pet类，同时加载它的属性方法

![image-20201119205144875](images/image-20201119205144875.png)

6. 栈中生成dog变量，指向堆中的Pet()对象

   ![image-20201119205327955](images/image-20201119205327955.png)

7. 对堆中的对象进行值的初始化

![image-20201119205418196](images/image-20201119205418196.png)

8. 使用常量池中的常量对其进行赋值

![image-20201119205517225](images/image-20201119205517225.png)

9. 假如我们再创建一个对象猫，那么在内存中，栈中生成变量cat,指向堆中的cat对象

![image-20201119205639437](images/image-20201119205639437.png)

引用对象在栈中仅仅是变量名，实际指向的是堆中的对象

10. static修饰的变量放在静态方法区，和类一起进行加载，无论哪个对象想使用静态的变量，都是可以的

![image-20201119205837258](images/image-20201119205837258.png)



### 简单小结面向对象

1. 类是一个模板是抽象的，而对象是一个具体的实例是具体
3. 方法主要包含方法的定义以及调用
4. 对象的引用，引用类型对应的是基本类型（基本类型是八大基础类型），对象是通过引用来操作的，引用就是对象所放在的地址
5. 对象的属性就是字段或者说成员变量，其包含默认初始化的机制

<img src="images/image-20201119210603013.png" alt="image-20201119210603013" style="zoom:67%;" />

　在JAVA里面的任何变量首先应该要声明，然后再赋值，然后再使用。**成员变量和局部变量有一个重要区别：**成员变量在类里面声明时如果不进行初始化，那么JAVA会默认给它初始化，而局部变量JAVA不会默认给它初始化，所以在方法里面声明一个局部变量如果不给它初始化时就会出错。默认初始化大多数都是0，boolean类型的为false，引用类型的为null，如过不记得JAVA对成员变量默认的初始化是多少的话，那就这样做，定义一个成员变量，不给它初始化，然后直接打印这个成员变量，打印出来的结果就是JAVA默认的初始化的值。

6. 对象的创建和使用必须要使用new关键字，需要调用构造器
7. 类中包含静态的属性和动态的行为，也就是属性和方法



## 封装详解

例子：看电视的时候，我们仅仅需要知道电视上的按钮的功能就可以了，而不用管电视内部是如何实现



**该露的露，该藏的藏**
我们程序设计要追求“高内聚，低耦合”。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉;低耦合:仅暴露少量的方法给外部使用。



**封装(数据的隐藏)|**
通常,应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称为信息隐藏，



记住这句话就够了:属性私有，get/set

```java
package com.dreamcold.oop;

public class Student {
   private String name;
   private Integer age;
   private Boolean sex;

    public Student() {

    }

    public Student(String name, Integer age, Boolean sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }


    public String getName() {
        return name;
    }

    public Integer getAge() {
        return age;
    }

    public Boolean getSex() {
        return sex;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public void setSex(Boolean sex) {
        this.sex = sex;
    }
}
```

- get是获得属性
- set是为属性设置值
- IDEA中alt+insert可以生成getter和setter方法
- 使用set可以规避不合法的数据

```java
 public void setAge(Integer age) {
        if(age<0||age>120){
            this.age=3;
        }else{
            this.age=age;
        }
}
```

**封装的作用**

1. 提高程序的安全性，保护数据
2. 隐藏代码的实现细节
3. 统一接口
4. 系统可维护增加了



## 继承详解

- 继承的本质是对某一批类的抽象， 从而实现对现实世界更好的建模。
- extands的意思是“扩展”。子类是父类的扩展。
- JAVA中类只有单继承，没有多继承!
- 继承是类和类之间的一种关系。除此之外,类和类之间的关系还有依赖、组合、聚合等。
- 继承关系的俩个类，一个为子类(派生类),一个为父类(基类)。子类继承父类,使用关键字extends来表示。
- 子类和父类之间,从意义.上讲应该具有"is a"的关系.

人类

```java
package com.dreamcold.oop;
//父类
public class Person {
}

```



学生类

```java
package com.dreamcold.oop;
//子类，派生类
public class Student extends Person {
}

```

老师类

```java
package com.dreamcold.oop;
//子类，派生类
public class Teacher extends Person {
}
```



### 子类可以继承得到父类的方法

父类中有say方法

```java
package com.dreamcold.oop;

public class Person {
    public void say(){
        System.out.println("say a word...");
    }
}
```

子类中没有方法

```java
package com.dreamcold.oop;

public class Student extends Person {

}
```

创建子类对象，调用父类中的say方法

```java
package com.dreamcold.oop;

public class Main {
    public static void main(String[] args) {
        Student student=new Student();
        student.say();
    }
}
```

1. 子类继承父类就会得到父类全部的方法
2. 父类私有的属性和方法子类是无法继承得到的
3. IDEA中ctrl+h就可以查看继承关系

### Object类

在Java中所有的类默认继承Object类

在Java中，即使没有声明父类，也有一个隐含的父类，这个父类叫Object。Object没有定 义属性，但
定义了一些方法，

<img src="images/image-20201120120242857.png" alt="image-20201120120242857" style="zoom:67%;" />



[Object类中的方法详解](https://www.cnblogs.com/zhangyinhua/p/7715486.html#_label0)

